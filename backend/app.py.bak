from flask import Flask, jsonify, request, session
import datetime
import sqlite3
import hashlib
import os
import secrets
from flask_cors import CORS
from functools import wraps
from dotenv import load_dotenv

# Load environment variables based on environment
if os.environ.get('FLASK_ENV') == 'production':
    load_dotenv('.env.production')
else:
    load_dotenv('.env.development')

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY') or os.urandom(24)  # Use environment variable or generate random key

# Get allowed origins from environment
cors_origin = os.environ.get('CORS_ORIGIN', 'http://localhost:3000')
allowed_origins = [origin.strip() for origin in cors_origin.split(',')]

# Configure CORS to allow credentials and specify the allowed origin
CORS(app, 
     supports_credentials=True,
     resources={r"/*": {"origins": allowed_origins}},  # Restrict to configured origins
     allow_headers=["Content-Type", "Authorization", "X-CSRF-Token"],
     expose_headers=["Set-Cookie", "X-CSRF-Token"])

# Set session configuration
app.config['SESSION_COOKIE_SAMESITE'] = 'Strict' if os.environ.get('FLASK_ENV') == 'production' else 'Lax'
app.config['SESSION_COOKIE_SECURE'] = os.environ.get('FLASK_ENV') == 'production'  # True in production with HTTPS
app.config['SESSION_COOKIE_HTTPONLY'] = True  # Prevent JavaScript access for security
app.config['PERMANENT_SESSION_LIFETIME'] = datetime.timedelta(days=7)  # Session expires after 7 days

# Initialize rate limiting
request_history = {}

# CSRF Protection middleware
def csrf_token():
    if 'csrf_token' not in session:
        session['csrf_token'] = secrets.token_hex(32)
    return session['csrf_token']

def csrf_protect(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.method in ['POST', 'PUT', 'DELETE']:
            token = request.headers.get('X-CSRF-Token')
            if not token or token != session.get('csrf_token'):
                return jsonify(error="CSRF token missing or invalid"), 403
        return f(*args, **kwargs)
    return decorated_function

# Rate limiting middleware
def rate_limit(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Get client IP
        client_ip = request.remote_addr
        
        # Initialize client in request history if not present
        if client_ip not in request_history:
            request_history[client_ip] = []
        
        # Get current time
        now = datetime.datetime.now()
        
        # Remove requests older than 1 minute
        request_history[client_ip] = [t for t in request_history[client_ip] 
                                     if (now - t).total_seconds() < 60]
        
        # Check if client has made more than 60 requests in the last minute
        if len(request_history[client_ip]) >= 60:
            return jsonify(error="Rate limit exceeded. Please try again later."), 429
        
        # Add current request to history
        request_history[client_ip].append(now)
        
        # Call the original function
        return f(*args, **kwargs)
    
    return decorated_function

# Authentication middleware decorator
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify(error="You must be logged in to access this resource."), 401
        return f(*args, **kwargs)
    return decorated_function

# Database setup function
def get_db_connection():
    db_path = os.environ.get('DATABASE_PATH', 'instance/choikk.db')
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn

# Password hashing function with salt
def hash_password(password):
    salt = os.urandom(32)  # 32 bytes of random data as a salt
    key = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)
    return salt.hex() + ':' + key.hex()

# Password verification function
def verify_password(stored_password, provided_password):
    salt_str, key_str = stored_password.split(':')
    salt = bytes.fromhex(salt_str)
    stored_key = bytes.fromhex(key_str)
    new_key = hashlib.pbkdf2_hmac('sha256', provided_password.encode(), salt, 100000)
    return stored_key == new_key

# Initialize database with tables and create default admin user if not exists
def init_db():
    # Check if instance directory exists, if not create it
    import os
    instance_dir = os.path.join(os.path.dirname(__file__), 'instance')
    if not os.path.exists(instance_dir):
        os.makedirs(instance_dir)
    
    db_path = os.path.join(instance_dir, 'choikk.db')
    db_exists = os.path.exists(db_path) and os.path.getsize(db_path) > 0
    
    # Connect to database
    conn = get_db_connection()
    
    # Create tables if they don't exist
    conn.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        email TEXT,
        role TEXT DEFAULT 'user',
        avatar_url TEXT,
        bio TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_login TIMESTAMP
    )
    ''')
    print("Ensured users table exists")
    
    conn.execute('''
    CREATE TABLE IF NOT EXISTS posts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        author_id INTEGER NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        tags TEXT,
        category TEXT DEFAULT 'general',
        view_count INTEGER DEFAULT 0,
        is_pinned BOOLEAN DEFAULT 0,
        FOREIGN KEY (author_id) REFERENCES users (id)
    )
    ''')
    print("Ensured posts table exists")
    
    conn.execute('''
    CREATE TABLE IF NOT EXISTS comments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        post_id INTEGER NOT NULL,
        author_id INTEGER NOT NULL,
        content TEXT NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (post_id) REFERENCES posts (id),
        FOREIGN KEY (author_id) REFERENCES users (id)
    )
    ''')
    print("Ensured comments table exists")
    
    conn.execute('''
    CREATE TABLE IF NOT EXISTS post_likes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        post_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(post_id, user_id),
        FOREIGN KEY (post_id) REFERENCES posts (id),
        FOREIGN KEY (user_id) REFERENCES users (id)
    )
    ''')
    print("Ensured post_likes table exists")
    
    conn.execute('''
    CREATE TABLE IF NOT EXISTS categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        description TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    print("Ensured categories table exists")
    
    # Only add default data if the database was just created
    if not db_exists:
        print("Creating initial data...")
          # Create a default admin user
        hashed_password = hash_password('admin123')
        conn.execute(
            'INSERT INTO users (username, password) VALUES (?, ?)',
            ('admin', hashed_password)
        )
        print("Added admin user")
        
        # Get the admin user id
        admin_user = conn.execute('SELECT * FROM users WHERE username = ?', ('admin',)).fetchone()
        admin_id = admin_user['id']
        print(f"Admin user ID: {admin_id}")
        
        # Add default categories
        categories = [
            ('General', 'General discussion topics'),
            ('Announcements', 'Official announcements'),
            ('Help', 'Questions and help requests'),
            ('Off-topic', 'Off-topic discussions')
        ]
        
        for category in categories:
            conn.execute(
                'INSERT INTO categories (name, description) VALUES (?, ?)',
                category
            )
        print("Added default categories")
        
        # Add a default welcome post
        conn.execute(
            'INSERT INTO posts (title, content, author_id, tags, category) VALUES (?, ?, ?, ?, ?)',
            ('Welcome to Choikk Forum', 'This is the first post on our forum. Feel free to register and start posting!', 
             admin_id, 'welcome,announcement', 'Announcements')
        )
        print("Added welcome post")
        
        # Add a second test post
        conn.execute(
            'INSERT INTO posts (title, content, author_id, tags, category) VALUES (?, ?, ?, ?, ?)',
            ('Second Test Post', 'This is another post to test if multiple posts are displayed properly.', 
             admin_id, 'test,debug', 'General')
        )
        print("Added second post")
        
        # Verify posts were added
        posts_count = conn.execute('SELECT COUNT(*) FROM posts').fetchone()[0]
        print(f"Total posts in database after initialization: {posts_count}")
    else:
        print(f"Using existing database at: {db_path}")
        
        # Add new tables if they don't exist when upgrading an existing database
        # We can run ALTER TABLE commands here if needed to migrate existing data
    
    conn.commit()
    conn.close()
    print("Database initialized successfully!")

# Initialize the database when app starts
init_db()

@app.route('/')
def home():
    # Ensure user is authenticated if you want to restrict even the home page
    if 'user_id' not in session:
        return jsonify(error="You must be logged in to access this page.", authenticated=False), 401
    
    return jsonify(message="Hello from Choikk backend!", authenticated=True)

@app.route('/status')
@login_required
def status():
    now = datetime.datetime.now()
    return jsonify(
        status="OK",
        timestamp=now.strftime("%Y-%m-%d %H:%M:%S"),
        message="Choikk backend is running smoothly!"
    )

# Authentication endpoints
@app.route('/register', methods=['POST'])
def register():
    username = request.json.get('username')
    password = request.json.get('password')
    
    if not username or not password:
        return jsonify(error="Username and password are required."), 400
    
    # Password complexity validation
    if len(password) < 8:
        return jsonify(error="Password must be at least 8 characters long."), 400
    
    # Hash the password
    hashed_password = hash_password(password)
    
    conn = get_db_connection()
    try:
        # Check if username already exists
        user = conn.execute('SELECT * FROM users WHERE username = ?', 
                          (username,)).fetchone()
        
        if user:
            conn.close()
            return jsonify(error="Username already exists."), 409
        
        # Insert new user - only using columns that exist in the schema
        cursor = conn.execute(
            'INSERT INTO users (username, password) VALUES (?, ?)',
            (username, hashed_password)
        )
        conn.commit()
          # Get the newly created user for return
        user_id = cursor.lastrowid
        new_user = conn.execute('SELECT id, username, created_at FROM users WHERE id = ?', 
                              (user_id,)).fetchone()
        
        user_data = {
            'id': new_user['id'],
            'username': new_user['username'],
            'created_at': new_user['created_at']
        }
          # Create session for the new user (auto-login)
        session['user_id'] = user_id
        session['username'] = username
        
        conn.close()
        return jsonify(user=user_data, message="Registration successful"), 201
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

@app.route('/login', methods=['POST'])
@rate_limit
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    
    if not username or not password:
        return jsonify(error="Username and password are required."), 400
    
    print(f"Login attempt: username={username}")
    
    conn = get_db_connection()
    user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()
    if not user or not verify_password(user['password'], password):
        print(f"Login failed: Invalid credentials for {username}")
        conn.close()
        return jsonify(error="Invalid username or password."), 401
    
    # Store user information in session
    session['user_id'] = user['id']
    session['username'] = user['username']
    print(f"Login successful: user_id={user['id']}, username={user['username']}")
    
    # Generate CSRF token for the session
    token = csrf_token()
    
    user_data = {
        'id': user['id'],
        'username': user['username']
    }
    
    conn.close()
    return jsonify(user=user_data, message="Login successful", csrf_token=token)

@app.route('/logout', methods=['POST'])
def logout():
    session.clear()
    return jsonify(message="Logout successful")

@app.route('/check_auth')
def check_auth():
    print("Checking auth. Session:", session)
    if 'user_id' in session:
        conn = get_db_connection()
        user = conn.execute('SELECT id, username FROM users WHERE id = ?', 
                          (session['user_id'],)).fetchone()
        conn.close()
        
        if user:
            user_data = {
                'id': user['id'],
                'username': user['username']
            }
            print("User authenticated:", user_data)
            return jsonify(authenticated=True, user=user_data)
    
    print("User not authenticated")
    return jsonify(authenticated=False)

# Posts endpoints (updated to use database)
@app.route('/posts')
@login_required
def get_all_posts():
    print("\n\n===== FETCHING POSTS =====")
    print("Fetching all posts for user_id:", session.get('user_id'))
    
    # Add pagination
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    offset = (page - 1) * per_page
    
    # Support filtering by category
    category = request.args.get('category')
    tag = request.args.get('tag')
    
    conn = get_db_connection()
    try:
        # First check if the posts table exists
        table_check = conn.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='posts'").fetchone()
        if not table_check:
            print("ERROR: Posts table does not exist!")
            conn.close()
            return jsonify({"error": "Posts table does not exist", "posts": []}), 500
        
        # Build query with potential filters
        query = '''
            SELECT p.id, p.title, p.content, p.timestamp, p.tags, p.category, p.view_count, 
                   u.username as author, u.id as author_id,
                   (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count,
                   (SELECT COUNT(*) FROM post_likes WHERE post_id = p.id) as like_count
            FROM posts p
            JOIN users u ON p.author_id = u.id
        '''
        
        params = []
        
        # Apply filters if they exist
        if category or tag:
            query += " WHERE "
            conditions = []
            
            if category:
                conditions.append("p.category = ?")
                params.append(category)
            
            if tag:
                conditions.append("p.tags LIKE ?")
                params.append(f"%{tag}%")
            
            query += " AND ".join(conditions)
            
        # Add ordering and pagination
        query += '''
            ORDER BY p.is_pinned DESC, p.timestamp DESC
            LIMIT ? OFFSET ?
        '''
        params.extend([per_page, offset])
        
        # Execute query
        posts_db = conn.execute(query, params).fetchall()
        
        # Count total posts for pagination (need to modify this query for filters too)
        count_query = 'SELECT COUNT(*) FROM posts p'
        if category or tag:
            count_query += " WHERE "
            conditions = []
            
            if category:
                conditions.append("p.category = ?")
            
            if tag:
                conditions.append("p.tags LIKE ?")
            
            count_query += " AND ".join(conditions)
        
        count_params = []
        if category:
            count_params.append(category)
        if tag:
            count_params.append(f"%{tag}%")
        
        total_posts = conn.execute(count_query, count_params).fetchone()[0]
        print(f"Total posts in database: {total_posts}, showing page {page} with {per_page} per page")
        
        posts = []
        for post in posts_db:
            # Parse tags from string to list
            tags = post['tags'].split(',') if post['tags'] else []
            
            # Check if current user liked this post
            liked = conn.execute(
                'SELECT 1 FROM post_likes WHERE post_id = ? AND user_id = ?',
                (post['id'], session['user_id'])
            ).fetchone() is not None
            
            post_dict = {
                'id': post['id'],
                'title': post['title'],
                'content': post['content'],
                'author': post['author'],
                'author_id': post['author_id'],
                'timestamp': post['timestamp'],
                'tags': tags,
                'category': post['category'],
                'view_count': post['view_count'],
                'comment_count': post['comment_count'],
                'like_count': post['like_count'],
                'liked_by_user': liked
            }
            posts.append(post_dict)
            print(f"Added post: {post_dict['id']} - {post_dict['title']}")
        
        # Calculate pagination info
        total_pages = (total_posts + per_page - 1) // per_page  # Ceiling division
        
        pagination = {
            'current_page': page,
            'total_pages': total_pages,
            'per_page': per_page,
            'total_items': total_posts,
            'has_next': page < total_pages,
            'has_prev': page > 1
        }
        
        print(f"Returning {len(posts)} posts with pagination info")
        conn.close()
        return jsonify({"posts": posts, "pagination": pagination})
    except Exception as e:
        print(f"ERROR fetching posts: {str(e)}")
        conn.close()
        return jsonify({"error": str(e), "posts": []}), 500

@app.route('/add_post', methods=['POST'])
@login_required
def add_post():
    title = request.json.get('title')
    content = request.json.get('content')
    tags = request.json.get('tags', [])
    category = request.json.get('category', 'General')
    
    if not title or not content:
        return jsonify(error="Title and content are required."), 400
    
    # Convert tags list to comma-separated string
    tags_str = ','.join(tags) if tags else ''
    
    conn = get_db_connection()
    try:
        # Verify that the category exists
        category_exists = conn.execute(
            'SELECT 1 FROM categories WHERE name = ?', 
            (category,)
        ).fetchone()
        
        if not category_exists:
            # Use default category if the provided one doesn't exist
            category = 'General'
        
        cursor = conn.execute(
            'INSERT INTO posts (title, content, author_id, tags, category) VALUES (?, ?, ?, ?, ?)',
            (title, content, session['user_id'], tags_str, category)
        )
        conn.commit()
        
        # Get the newly created post
        post_id = cursor.lastrowid
        post_db = conn.execute('''
            SELECT p.id, p.title, p.content, p.timestamp, p.tags, p.category, p.view_count,
                   u.username as author, u.id as author_id
            FROM posts p
            JOIN users u ON p.author_id = u.id
            WHERE p.id = ?
        ''', (post_id,)).fetchone()
        
        # Parse tags back to list
        tags_list = post_db['tags'].split(',') if post_db['tags'] else []
        
        post = {
            'id': post_db['id'],
            'title': post_db['title'],
            'content': post_db['content'],
            'author': post_db['author'],
            'author_id': post_db['author_id'],
            'timestamp': post_db['timestamp'],
            'tags': tags_list,
            'category': post_db['category'],
            'view_count': post_db['view_count'],
            'comment_count': 0,
            'like_count': 0,
            'liked_by_user': False
        }
        
        conn.close()
        return jsonify(post=post, message="Post created successfully"), 201
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

@app.route('/posts/<int:id>')
@login_required
def get_post(id):
    conn = get_db_connection()
    
    # Get post with additional information
    post_db = conn.execute('''
        SELECT p.id, p.title, p.content, p.timestamp, p.tags, p.category, p.view_count,
               u.username as author, u.id as author_id,
               (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count,
               (SELECT COUNT(*) FROM post_likes WHERE post_id = p.id) as like_count
        FROM posts p
        JOIN users u ON p.author_id = u.id
        WHERE p.id = ?
    ''', (id,)).fetchone()
    
    if not post_db:
        conn.close()
        return jsonify(error="Post not found"), 404
    
    # Increment view count
    conn.execute('UPDATE posts SET view_count = view_count + 1 WHERE id = ?', (id,))
    conn.commit()
    
    # Parse tags from string to list
    tags = post_db['tags'].split(',') if post_db['tags'] else []
    
    # Check if current user liked this post
    liked = conn.execute(
        'SELECT 1 FROM post_likes WHERE post_id = ? AND user_id = ?',
        (post_db['id'], session['user_id'])
    ).fetchone() is not None
    
    # Get comments for this post
    comments_db = conn.execute('''
        SELECT c.id, c.content, c.timestamp, u.username as author, u.id as author_id
        FROM comments c
        JOIN users u ON c.author_id = u.id
        WHERE c.post_id = ?
        ORDER BY c.timestamp ASC
    ''', (id,)).fetchall()
    
    comments = []
    for comment in comments_db:
        comments.append({
            'id': comment['id'],
            'content': comment['content'],
            'author': comment['author'],
            'author_id': comment['author_id'],
            'timestamp': comment['timestamp']
        })
    
    post = {
        'id': post_db['id'],
        'title': post_db['title'],
        'content': post_db['content'],
        'author': post_db['author'],
        'author_id': post_db['author_id'],
        'timestamp': post_db['timestamp'],
        'tags': tags,
        'category': post_db['category'],
        'view_count': post_db['view_count'] + 1,  # Include the increment we just made
        'comment_count': post_db['comment_count'],
        'like_count': post_db['like_count'],
        'liked_by_user': liked,
        'comments': comments
    }
    
    conn.close()
    return jsonify(post=post)

@app.route('/user/posts')
@login_required
def get_user_posts():
    conn = get_db_connection()
    posts_db = conn.execute('''
        SELECT p.id, p.title, p.content, p.timestamp, p.tags, u.username as author
        FROM posts p
        JOIN users u ON p.author_id = u.id
        WHERE p.author_id = ?
        ORDER BY p.timestamp DESC
    ''', (session['user_id'],)).fetchall()
    
    posts = []
    for post in posts_db:
        # Parse tags from string to list
        tags = post['tags'].split(',') if post['tags'] else []
        
        posts.append({
            'id': post['id'],
            'title': post['title'],
            'content': post['content'],
            'author': post['author'],
            'timestamp': post['timestamp'],
            'tags': tags
        })
    
    conn.close()
    return jsonify(posts=posts)

@app.route('/debug_db')
def debug_db():
    conn = get_db_connection()
    try:
        # Check if tables exist
        tables = conn.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()
        table_names = [table['name'] for table in tables]
        
        # Get user count
        user_count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        users = conn.execute('SELECT id, username FROM users').fetchall()
        user_list = [{'id': user['id'], 'username': user['username']} for user in users]
        
        # Get post count
        post_count = conn.execute('SELECT COUNT(*) FROM posts').fetchone()[0]
        posts = conn.execute('SELECT id, title, author_id FROM posts').fetchall()
        post_list = [{'id': post['id'], 'title': post['title'], 'author_id': post['author_id']} for post in posts]
        
        conn.close()
        return jsonify({
            'tables': table_names,
            'user_count': user_count,
            'users': user_list,
            'post_count': post_count,
            'posts': post_list
        })
    except Exception as e:
        conn.close()
        return jsonify({'error': str(e)}), 500

@app.route('/test_posts')
def test_posts():
    """A test endpoint to get posts without authentication for debugging"""
    conn = get_db_connection()
    try:
        posts_db = conn.execute('''
            SELECT p.id, p.title, p.content, p.timestamp, p.tags, u.username as author
            FROM posts p
            JOIN users u ON p.author_id = u.id
            ORDER BY p.timestamp DESC
        ''').fetchall()
        
        posts = []
        for post in posts_db:
            # Parse tags from string to list
            tags = post['tags'].split(',') if post['tags'] else []
            
            post_dict = {
                'id': post['id'],
                'title': post['title'],
                'content': post['content'],
                'author': post['author'],
                'timestamp': post['timestamp'],
                'tags': tags
            }
            posts.append(post_dict)
        
        conn.close()
        return jsonify({"posts": posts})
    except Exception as e:
        conn.close()
        return jsonify({"error": str(e), "posts": []}), 500

# Comments endpoints
@app.route('/posts/<int:post_id>/comments', methods=['GET'])
@login_required
def get_comments(post_id):
    conn = get_db_connection()
    
    # Check if post exists
    post = conn.execute('SELECT * FROM posts WHERE id = ?', (post_id,)).fetchone()
    if not post:
        conn.close()
        return jsonify(error="Post not found"), 404
    
    comments_db = conn.execute('''
        SELECT c.id, c.content, c.timestamp, u.username as author, u.id as author_id
        FROM comments c
        JOIN users u ON c.author_id = u.id
        WHERE c.post_id = ?
        ORDER BY c.timestamp ASC
    ''', (post_id,)).fetchall()
    
    comments = []
    for comment in comments_db:
        comments.append({
            'id': comment['id'],
            'content': comment['content'],
            'author': comment['author'],
            'author_id': comment['author_id'],
            'timestamp': comment['timestamp']
        })
    
    conn.close()
    return jsonify(comments=comments)

@app.route('/posts/<int:post_id>/comments', methods=['POST'])
@login_required
def add_comment(post_id):
    content = request.json.get('content')
    
    if not content:
        return jsonify(error="Comment content is required."), 400
    
    conn = get_db_connection()
    
    # Check if post exists
    post = conn.execute('SELECT * FROM posts WHERE id = ?', (post_id,)).fetchone()
    if not post:
        conn.close()
        return jsonify(error="Post not found"), 404
    
    try:
        cursor = conn.execute(
            'INSERT INTO comments (post_id, author_id, content) VALUES (?, ?, ?)',
            (post_id, session['user_id'], content)
        )
        conn.commit()
        
        # Get the newly created comment
        comment_id = cursor.lastrowid
        comment_db = conn.execute('''
            SELECT c.id, c.content, c.timestamp, u.username as author, u.id as author_id
            FROM comments c
            JOIN users u ON c.author_id = u.id
            WHERE c.id = ?
        ''', (comment_id,)).fetchone()
        
        comment = {
            'id': comment_db['id'],
            'content': comment_db['content'],
            'author': comment_db['author'],
            'author_id': comment_db['author_id'],
            'timestamp': comment_db['timestamp']
        }
        
        conn.close()
        return jsonify(comment=comment, message="Comment added successfully"), 201
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

@app.route('/comments/<int:comment_id>', methods=['DELETE'])
@login_required
def delete_comment(comment_id):
    conn = get_db_connection()
    
    # Check if comment exists and belongs to the user
    comment = conn.execute('''
        SELECT * FROM comments WHERE id = ?
    ''', (comment_id,)).fetchone()
    
    if not comment:
        conn.close()
        return jsonify(error="Comment not found"), 404
      # Check if user is the author (admin check is removed as we don't have roles)
    if comment['author_id'] != session['user_id']:
        conn.close()
        return jsonify(error="You don't have permission to delete this comment"), 403
    
    try:
        conn.execute('DELETE FROM comments WHERE id = ?', (comment_id,))
        conn.commit()
        conn.close()
        return jsonify(message="Comment deleted successfully")
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

# Likes endpoints
@app.route('/posts/<int:post_id>/like', methods=['POST'])
@login_required
def like_post(post_id):
    conn = get_db_connection()
    
    # Check if post exists
    post = conn.execute('SELECT * FROM posts WHERE id = ?', (post_id,)).fetchone()
    if not post:
        conn.close()
        return jsonify(error="Post not found"), 404
    
    # Check if user already liked the post
    like = conn.execute(
        'SELECT * FROM post_likes WHERE post_id = ? AND user_id = ?',
        (post_id, session['user_id'])
    ).fetchone()
    
    if like:
        # Unlike the post
        conn.execute(
            'DELETE FROM post_likes WHERE post_id = ? AND user_id = ?',
            (post_id, session['user_id'])
        )
        conn.commit()
        
        # Count updated likes
        likes_count = conn.execute(
            'SELECT COUNT(*) FROM post_likes WHERE post_id = ?',
            (post_id,)
        ).fetchone()[0]
        
        conn.close()
        return jsonify(liked=False, likes_count=likes_count, message="Post unliked")
    else:
        # Like the post
        try:
            conn.execute(
                'INSERT INTO post_likes (post_id, user_id) VALUES (?, ?)',
                (post_id, session['user_id'])
            )
            conn.commit()
            
            # Count updated likes
            likes_count = conn.execute(
                'SELECT COUNT(*) FROM post_likes WHERE post_id = ?',
                (post_id,)
            ).fetchone()[0]
            
            conn.close()
            return jsonify(liked=True, likes_count=likes_count, message="Post liked")
        except Exception as e:
            conn.close()
            return jsonify(error=str(e)), 500

@app.route('/posts/<int:post_id>/likes', methods=['GET'])
def get_post_likes(post_id):
    conn = get_db_connection()
    
    # Check if post exists
    post = conn.execute('SELECT * FROM posts WHERE id = ?', (post_id,)).fetchone()
    if not post:
        conn.close()
        return jsonify(error="Post not found"), 404
    
    # Count likes
    likes_count = conn.execute(
        'SELECT COUNT(*) FROM post_likes WHERE post_id = ?',
        (post_id,)
    ).fetchone()[0]
    
    # Check if current user liked the post
    liked = False
    if 'user_id' in session:
        like = conn.execute(
            'SELECT * FROM post_likes WHERE post_id = ? AND user_id = ?',
            (post_id, session['user_id'])
        ).fetchone()
        liked = like is not None
    
    conn.close()
    return jsonify(liked=liked, likes_count=likes_count)

# Categories endpoints
@app.route('/categories', methods=['GET'])
def get_categories():
    conn = get_db_connection()
    categories_db = conn.execute('SELECT * FROM categories ORDER BY name').fetchall()
    
    categories = []
    for category in categories_db:
        categories.append({
            'id': category['id'],
            'name': category['name'],
            'description': category['description']
        })
    
    conn.close()
    return jsonify(categories=categories)

@app.route('/categories/<int:category_id>/posts', methods=['GET'])
def get_category_posts(category_id):
    # Add pagination
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    offset = (page - 1) * per_page
    
    conn = get_db_connection()
    
    # Get category info
    category = conn.execute('SELECT * FROM categories WHERE id = ?', (category_id,)).fetchone()
    if not category:
        conn.close()
        return jsonify(error="Category not found"), 404
    
    # Get posts for this category with pagination
    posts_db = conn.execute('''
        SELECT p.id, p.title, p.content, p.timestamp, p.tags, u.username as author,
               (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count,
               (SELECT COUNT(*) FROM post_likes WHERE post_id = p.id) as like_count
        FROM posts p
        JOIN users u ON p.author_id = u.id
        WHERE p.category = ?
        ORDER BY p.timestamp DESC
        LIMIT ? OFFSET ?
    ''', (category['name'], per_page, offset)).fetchall()
    
    # Count total posts for pagination
    total_posts = conn.execute(
        'SELECT COUNT(*) FROM posts WHERE category = ?',
        (category['name'],)
    ).fetchone()[0]
    
    posts = []
    for post in posts_db:
        # Parse tags from string to list
        tags = post['tags'].split(',') if post['tags'] else []
        
        posts.append({
            'id': post['id'],
            'title': post['title'],
            'content': post['content'],
            'author': post['author'],
            'timestamp': post['timestamp'],
            'tags': tags,
            'comment_count': post['comment_count'],
            'like_count': post['like_count']
        })
    
    # Calculate pagination info
    total_pages = (total_posts + per_page - 1) // per_page  # Ceiling division
    
    pagination = {
        'current_page': page,
        'total_pages': total_pages,
        'per_page': per_page,
        'total_items': total_posts,
        'has_next': page < total_pages,
        'has_prev': page > 1
    }
    
    conn.close()
    return jsonify(
        category={'id': category['id'], 'name': category['name'], 'description': category['description']},
        posts=posts,
        pagination=pagination
    )

# User profile and account management
@app.route('/user/profile', methods=['GET'])
@login_required
def get_user_profile():
    user_id = session.get('user_id')
      conn = get_db_connection()
    user = conn.execute('''
        SELECT id, username, created_at 
        FROM users
        WHERE id = ?
    ''', (user_id,)).fetchone()
    
    if not user:
        conn.close()
        return jsonify(error="User not found"), 404
    
    # Count user's posts
    post_count = conn.execute(
        'SELECT COUNT(*) FROM posts WHERE author_id = ?',
        (user_id,)
    ).fetchone()[0]
    
    # Count user's comments
    comment_count = conn.execute(
        'SELECT COUNT(*) FROM comments WHERE author_id = ?',
        (user_id,)
    ).fetchone()[0]
      user_data = {
        'id': user['id'],
        'username': user['username'],
        'created_at': user['created_at'],
        'post_count': post_count,
        'comment_count': comment_count
    }
    
    conn.close()
    return jsonify(user=user_data)

@app.route('/user/profile', methods=['PUT'])
@login_required
@csrf_protect
def update_user_profile():
    user_id = session.get('user_id')
      # Get fields to update
    bio = request.json.get('bio')
    avatar_url = request.json.get('avatar_url')
    
    conn = get_db_connection()
    
    try:        # Update fields
        query = 'UPDATE users SET '
        params = []
        update_fields = []
        
        if bio is not None:
            update_fields.append('bio = ?')
            params.append(bio)
        
        if avatar_url is not None:
            update_fields.append('avatar_url = ?')
            params.append(avatar_url)
        
        if not update_fields:
            conn.close()
            return jsonify(error="No fields to update."), 400
        
        query += ', '.join(update_fields)
        query += ' WHERE id = ?'
        params.append(user_id)
        
        conn.execute(query, params)
        conn.commit()
          # Get updated user profile
        user = conn.execute('''
            SELECT id, username, created_at
            FROM users
            WHERE id = ?
        ''', (user_id,)).fetchone()
        
        user_data = {
            'id': user['id'],
            'username': user['username'],
            'created_at': user['created_at']
        }
        
        conn.close()
        return jsonify(user=user_data, message="Profile updated successfully")
    
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

@app.route('/user/change-password', methods=['PUT'])
@login_required
@csrf_protect
def change_password():
    user_id = session.get('user_id')
    
    # Get password data
    current_password = request.json.get('current_password')
    new_password = request.json.get('new_password')
    
    if not current_password or not new_password:
        return jsonify(error="Current password and new password are required."), 400
    
    # Password complexity validation
    if len(new_password) < 8:
        return jsonify(error="New password must be at least 8 characters long."), 400
    
    conn = get_db_connection()
    
    # Verify current password
    user = conn.execute('SELECT password FROM users WHERE id = ?', (user_id,)).fetchone()
    
    if not verify_password(user['password'], current_password):
        conn.close()
        return jsonify(error="Current password is incorrect."), 401
    
    # Hash and store new password
    hashed_password = hash_password(new_password)
    
    try:
        conn.execute(
            'UPDATE users SET password = ? WHERE id = ?',
            (hashed_password, user_id)
        )
        conn.commit()
        conn.close()
        
        return jsonify(message="Password changed successfully")
    
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

# Admin routes
@app.route('/admin/users', methods=['GET'])
@login_required
def admin_get_users():
    # Since we don't have role-based access, check if user is admin by username
    conn = get_db_connection()
    user = conn.execute('SELECT username FROM users WHERE id = ?', (session.get('user_id'),)).fetchone()
    
    if not user or user['username'] != 'admin':
        conn.close()
        return jsonify(error="Unauthorized. Admin access required."), 403
      conn = get_db_connection()
    users_db = conn.execute('''
        SELECT id, username, created_at,
               (SELECT COUNT(*) FROM posts WHERE author_id = users.id) as post_count
        FROM users
        ORDER BY id ASC
    ''').fetchall()
    
    users = []
    for user in users_db:
        users.append({
            'id': user['id'],
            'username': user['username'],
            'created_at': user['created_at'],
            'post_count': user['post_count']
        })
    
    conn.close()
    return jsonify(users=users)

@app.route('/admin/users/<int:user_id>', methods=['PUT'])
@login_required
@csrf_protect
def admin_update_user(user_id):
    # Since we don't have a role column, this feature is not available
    return jsonify(error="Feature not available. User roles are not supported."), 400
        
        conn.close()
        return jsonify(user=user_data, message="User updated successfully")
    
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

@app.route('/admin/stats', methods=['GET'])
@login_required
def admin_stats():
    # Check if user is admin
    if session.get('role') != 'admin':
        return jsonify(error="Unauthorized. Admin access required."), 403
    
    conn = get_db_connection()
    
    try:
        # Get user stats
        total_users = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        recent_users = conn.execute(
            'SELECT COUNT(*) FROM users WHERE created_at > datetime("now", "-7 day")'
        ).fetchone()[0]
        
        # Get post stats
        total_posts = conn.execute('SELECT COUNT(*) FROM posts').fetchone()[0]
        recent_posts = conn.execute(
            'SELECT COUNT(*) FROM posts WHERE timestamp > datetime("now", "-7 day")'
        ).fetchone()[0]
        
        # Get comment stats
        total_comments = conn.execute('SELECT COUNT(*) FROM comments').fetchone()[0]
        recent_comments = conn.execute(
            'SELECT COUNT(*) FROM comments WHERE timestamp > datetime("now", "-7 day")'
        ).fetchone()[0]
        
        # Get top posts by views
        top_posts_by_views = conn.execute('''
            SELECT p.id, p.title, p.view_count, u.username as author
            FROM posts p
            JOIN users u ON p.author_id = u.id
            ORDER BY p.view_count DESC
            LIMIT 5
        ''').fetchall()
        
        top_views = []
        for post in top_posts_by_views:
            top_views.append({
                'id': post['id'],
                'title': post['title'],
                'author': post['author'],
                'view_count': post['view_count']
            })
        
        # Get top posts by likes
        top_posts_by_likes = conn.execute('''
            SELECT p.id, p.title, COUNT(pl.id) as like_count, u.username as author
            FROM posts p
            JOIN users u ON p.author_id = u.id
            LEFT JOIN post_likes pl ON p.id = pl.post_id
            GROUP BY p.id
            ORDER BY like_count DESC
            LIMIT 5
        ''').fetchall()
        
        top_likes = []
        for post in top_posts_by_likes:
            top_likes.append({
                'id': post['id'],
                'title': post['title'],
                'author': post['author'],
                'like_count': post['like_count']
            })
        
        # Get top categories
        top_categories = conn.execute('''
            SELECT category, COUNT(*) as post_count
            FROM posts
            GROUP BY category
            ORDER BY post_count DESC
            LIMIT 5
        ''').fetchall()
        
        categories_data = []
        for cat in top_categories:
            categories_data.append({
                'name': cat['category'],
                'post_count': cat['post_count']
            })
        
        stats = {
            'users': {
                'total': total_users,
                'recent': recent_users
            },
            'posts': {
                'total': total_posts,
                'recent': recent_posts
            },
            'comments': {
                'total': total_comments,
                'recent': recent_comments
            },
            'top_posts_by_views': top_views,
            'top_posts_by_likes': top_likes,
            'top_categories': categories_data
        }
        
        conn.close()
        return jsonify(stats=stats)
    
    except Exception as e:
        conn.close()
        return jsonify(error=str(e)), 500

if __name__ == '__main__':
    app.run(debug=True)
